/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.HashMap
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.ExternalMethod
import dk.sdu.mmmi.mdsd.math.Parameter
import dk.sdu.mmmi.mdsd.math.ExternalUse
import java.util.ArrayList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {
	
	static Map<String, String> variables;
	static Map<String, String> externals;
	static ArrayList params = newArrayList('n', 'm')
	static int counter = 0;
	
	static boolean letBinding;
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		variables = new HashMap()
		externals = new HashMap()
		letBinding = false;
		val math = resource.allContents.filter(MathExp).next
		fsa.generateFile('math_expression/' + math.name + ".java", math.compile)
		
	}
	
	def compile(MathExp math)'''
	package math_expression;
	public class «math.name» {
		«FOR variable: math.variables»
			public int «variable.name»;
		«ENDFOR»
	
	«IF math.externals.length !== 0»
		public External external;
	
		public interface External {
	  	«FOR external : math.externals»
	  		«IF external.parameters.length !== 0»
	  		public int «external.name»(«FOR parameter : external.parameters SEPARATOR ","»«parameter.name» «params.get(external.parameters.indexOf(parameter))»«ENDFOR»);
		  	«ELSE»
	  		public int «external.name»();
	  		«ENDIF»
		«ENDFOR»
	}
	
		public «math.name»(External external) {
			this.external = external;
		}
	«ENDIF»

	  	public void compute() {
	  	
	  	«FOR variable:math.variables»
	  		«variable.name» = «variable.expression.computeExpression»;
	  	«ENDFOR»
	  	
	  	
	  	}
	  	
	«IF letBinding == true»
		public interface InnerBinding{
			public int computeLetBinding();
		}	  	
	«ENDIF»
	}
	'''
	
 	

		
	def static compute(MathExp math) {
		for(varBinding: math.variables){
			varBinding.computeExpression()
		}
		for(external: math.externals){
			external.computeExpression()
		}
		variables
	}
	
	def static dispatch String computeExpression(VarBinding binding) {
		variables.put(binding.name, binding.expression.computeExpression())
		return binding.name
	}
	
	def static dispatch String computeExpression(ExternalMethod externalMethod){
		for (parameter : externalMethod.parameters) {
			externals.put(externalMethod.name, parameter.computeExpression())
		}
		return externalMethod.name
	}
	
	def static dispatch String computeExpression(MathNumber exp) {
		return exp.value.toString
	}
  
	def static dispatch String computeExpression(Plus exp) {
		return '(' + exp.left.computeExpression + "+" + exp.right.computeExpression + ')'
	}
	
	def static dispatch String computeExpression(Minus exp) {
		return '(' + exp.left.computeExpression + "-" + exp.right.computeExpression + ')'
	}
	
	def static dispatch String computeExpression(Mult exp) {
		return '(' + exp.left.computeExpression + "*" + exp.right.computeExpression + ')'
	}
	
	def static dispatch String computeExpression(Div exp) {
		return '(' + exp.left.computeExpression + "/" + exp.right.computeExpression + ')'
	}

	def static dispatch String computeExpression(LetBinding exp) {
		letBinding = true;
		'''
		new InnerBinding() {
			public int computeLetBinding(){
					int tempResult = «exp.binding.computeExpression»;
					int «exp.name» = tempResult;
					return «exp.body.computeExpression»;
				}
			}.computeLetBinding()
		'''
	}

	def static dispatch String computeExpression(VariableUse exp) {
		return exp.ref.computeBinding
	}
	
	def static dispatch String computeExpression(ExternalUse exp){
		return 
		'''
			external.«exp.name»(«FOR parameter : exp.parameters SEPARATOR ","»«parameter.computeExpression»«ENDFOR»)
		'''
	}
	
	def static dispatch String computeBinding(VarBinding binding){
		if(!variables.containsKey(binding.name))
			binding.computeExpression() 
		binding.name
	}
	
	def static dispatch String computeBinding(LetBinding binding){
		return binding.name
	}
	
}
